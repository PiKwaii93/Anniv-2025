<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bingo de Soir√©e</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #0f172a; /* Bleu nuit pour l'ambiance soir√©e */
        }
        /* La grille reste 4x4, mais on assure une taille minimale des cellules pour le toucher */
        .bingo-grid {
            /* S'assurer que la grille utilise le mod√®le grid */
            display: grid; 
            grid-template-columns: repeat(4, minmax(0, 1fr));
            gap: 0.5rem; 
        }

        /* Style de base pour une cellule */
        .grid-cell {
            /* La hauteur est dict√©e par le contenu (texte) le plus long de la ligne Grid */
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            padding: 0.75rem 0.5rem; /* Padding vertical et horizontal pour l'espace */
            min-height: 4rem; /* Assure une hauteur minimale pour le toucher sur mobile */
            
            line-height: 1.3; /* Ligne plus haute pour la lisibilit√© du texte long */
            word-break: break-word; /* Force les mots trop longs √† se couper pour √©viter le d√©bordement horizontal */
            
            border-radius: 0.75rem; /* rounded-xl */
            transition: all 0.2s ease-in-out;
            user-select: none;
            cursor: pointer;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            white-space: normal; /* S'assure que le texte passe √† la ligne */

            /* Le JS va d√©finir la taille de police dynamiquement ici */
        }
        
        /* Au-del√† de sm (tablet/desktop), on peut augmenter le padding et la hauteur minimale */
        @media (min-width: 640px) {
            .grid-cell {
                padding: 1rem;
                min-height: 6rem;
            }
        }

        /* Effet visuel au clic */
        .grid-cell:active {
            transform: scale(0.95);
        }

        /* Case non valid√©e */
        .not-validated {
            background-color: #374151; /* gray-700 */
            color: #d1d5db; /* gray-300 */
            border: 2px solid #4b5563; /* gray-600 */
        }

        /* Case valid√©e (Bingo) */
        .validated {
            background-color: #ef4444; /* red-500 */
            color: white;
            font-weight: bold;
            border: 2px solid #dc2626; /* red-600 */
            transform: scale(1.05); /* Effet d'accentuation */
        }
    </style>
</head>
<body class="text-white flex items-center justify-center min-h-screen p-2 md:p-4">
    
    <!-- Conteneur principal: max-w-full sur mobile et utilisation de 'mx-auto' pour centrer -->
    <div class="w-full max-w-4xl p-4 md:p-6 bg-slate-800 rounded-2xl shadow-2xl flex flex-col items-center space-y-4 md:space-y-6 border border-slate-700 min-h-[95vh] mx-auto">
        
        <div class="text-center w-full">
            <h1 class="text-3xl md:text-5xl font-bold tracking-tight text-transparent bg-clip-text bg-gradient-to-r from-pink-500 to-red-500">
                üéâ Bingo de Soir√©e
            </h1>
            <p class="mt-2 text-sm md:text-lg text-slate-400 font-medium">
                Validez toutes les 16 cases pour gagner le Bingo Complet !
            </p>
        </div>

        <!-- Section Statut de Victoire -->
        <div id="winStatus" class="w-full text-center p-3 rounded-xl bg-green-900/50 border border-green-700 hidden">
            <p class="text-xl md:text-2xl font-bold text-green-300">
                ü•≥ BINGO COMPLET ! Vous avez gagn√© !
            </p>
        </div>

        <!-- Grille de Bingo -->
        <div id="bingoGrid" class="bingo-grid w-full flex-grow">
            <!-- Les cases seront g√©n√©r√©es ici par JavaScript -->
        </div>

        <!-- Boutons d'action -->
        <div class="flex flex-col md:flex-row gap-4 w-full md:w-auto mt-auto">
            <button id="newGridBtn" 
                    class="w-full md:w-auto bg-red-600 hover:bg-red-700 text-white font-bold py-3 px-6 rounded-xl shadow-lg transition duration-150 transform hover:scale-105">
                Nouvelle Grille
            </button>
            <a href="index.html" 
               class="w-full md:w-auto bg-slate-600 hover:bg-slate-700 text-white font-bold py-3 px-6 rounded-xl shadow-lg transition duration-150 text-center flex items-center justify-center transform hover:scale-105">
                <span class="mr-2">üè†</span> Accueil
            </a>
        </div>
    </div>

    <script>
        // Constantes pour le jeu
        const GRID_SIZE = 4; // 4x4
        const TOTAL_SQUARES = GRID_SIZE * GRID_SIZE;
        const LOCAL_KEY = 'partyBingoGrid';
        
        // Taille maximale de la police pour √©viter un texte trop gros pour les courtes entr√©es
        const MAX_FONT_SIZE_PX = window.innerWidth < 640 ? 16 : 24; 
        // Taille minimale de la police pour la lisibilit√©
        const MIN_FONT_SIZE_PX = window.innerWidth < 640 ? 10 : 12; 

        // Actions de Bingo (√† personnaliser selon votre soir√©e !)
        const bingoActions = [
            "Quelqu'un raconte une anecdote embarrassante.",
            "Un invit√© se plaint de la musique.",
            "Quelqu'un utilise le mot 'litt√©ralement'.",
            "Un smartphone est cass√© ou tombe dans l'eau.",
            "On voit un 'danseur' embarrassant.",
            "Un invit√© mentionne son travail plus de trois fois.",
            "On commande de la nourriture √† emporter.",
            "Le chien ou le chat devient le centre de l'attention.",
            "Un d√©bat politique/religieux √©clate.",
            "Quelqu'un propose un shot de tequila.",
            "On entend une chanson de C√©line Dion (ou similaire).",
            "Un couple se dispute.",
            "Quelqu'un fait un 'cheers' trop long.",
            "Un invit√© est d√©j√† parti avant minuit.",
            "Quelqu'un apporte un plat bizarre/non demand√©.",
            "Un invit√© pose une question de quiz sans conna√Ætre la r√©ponse.",
            "Quelqu'un oublie le pr√©nom d'un autre invit√©.",
            "Une personne parle d'une s√©rie que personne d'autre n'a vue.",
            "Un invit√© dit 'J'√©tais pas si saoul que √ßa...' en parlant du pass√©.",
            "Quelqu'un fait une imitation rat√©e.",
            "La lumi√®re est tamis√©e pour l'ambiance.",
            "Un invit√© se prend pour le DJ.",
            "On entend un rire de m√©chant de dessin anim√©.",
            "Quelqu'un parle de sport intens√©ment.",
            "Un invit√© propose de faire un jeu de soci√©t√©.",
            "Quelqu'un utilise une expression tr√®s vieille/d√©mod√©e.",
        ];

        // R√©f√©rences DOM
        const bingoGrid = document.getElementById('bingoGrid');
        const newGridBtn = document.getElementById('newGridBtn');
        const winStatus = document.getElementById('winStatus');


        // --- Fonctions d'Utilit√© ---

        function shuffle(array) {
            let currentIndex = array.length, randomIndex;
            while (currentIndex !== 0) {
                randomIndex = Math.floor(Math.random() * currentIndex);
                currentIndex--;
                [array[currentIndex], array[randomIndex]] = [array[randomIndex], array[currentIndex]];
            }
            return array;
        }

        function saveGridState(state) {
            try {
                localStorage.setItem(LOCAL_KEY, JSON.stringify(state));
            } catch (error) {
                console.error("Erreur lors de la sauvegarde de l'√©tat :", error);
            }
        }

        function loadGridState() {
            try {
                const stored = localStorage.getItem(LOCAL_KEY);
                return stored ? JSON.parse(stored) : null;
            } catch (error) {
                console.error("Erreur lors du chargement de l'√©tat :", error);
                return null;
            }
        }

        /**
         * Calcule la taille de police maximale pour qu'un texte tienne dans sa cellule,
         * en utilisant la hauteur d√©j√† d√©finie par le Grid Layout (qui garantit l'alignement des lignes).
         * @param {string} text Le texte √† ins√©rer.
         * @param {HTMLElement} element L'√©l√©ment DOM de la cellule.
         * @returns {number} La taille de police en pixels.
         */
        function calculateFontSize(text, element) {
            // Cloner l'√©l√©ment pour mesurer sans affecter le layout original
            const clone = element.cloneNode(true);
            clone.textContent = text;
            
            // Appliquer les styles de positionnement pour que le clone ne perturbe pas le DOM visible
            clone.style.fontSize = `${MAX_FONT_SIZE_PX}px`;
            
            // CRITIQUE : Utiliser la largeur et la hauteur r√©elles de l'√©l√©ment parent.
            // On s'assure que le clone prend la m√™me taille que sa destination.
            clone.style.width = element.offsetWidth + 'px'; 
            clone.style.height = element.offsetHeight + 'px';
            
            clone.style.position = 'absolute';
            clone.style.top = '-9999px'; // Le placer loin de la vue
            clone.style.visibility = 'hidden';
            
            document.body.appendChild(clone);

            let fontSize = MAX_FONT_SIZE_PX;
            
            // La hauteur cible est la hauteur de la case r√©elle moins le padding et une petite marge de s√©curit√© (4px)
            const computedStyle = getComputedStyle(element);
            const paddingTop = parseFloat(computedStyle.paddingTop);
            const paddingBottom = parseFloat(computedStyle.paddingBottom);
            const targetHeight = element.offsetHeight - (paddingTop + paddingBottom) - 4; 
            
            // Boucle pour r√©duire la taille de police tant que le contenu d√©borde de la hauteur de la case
            // Note: Nous utilisons offsetHeight du clone qui est initialement fix√© √† element.offsetHeight
            while (clone.scrollHeight > targetHeight && fontSize > MIN_FONT_SIZE_PX) {
                fontSize -= 0.5;
                clone.style.fontSize = `${fontSize}px`;
            }

            document.body.removeChild(clone);

            // Retourne la taille calcul√©e, sans jamais √™tre inf√©rieure √† la taille minimale
            return Math.max(fontSize, MIN_FONT_SIZE_PX);
        }


        // --- Logique du Jeu ---

        function checkWin(gridState) {
            if (!gridState || gridState.length !== TOTAL_SQUARES) {
                showWinStatus(false);
                return false;
            }

            // MODIFICATION: V√©rifie si TOUTES les cases sont valid√©es
            const allValidated = gridState.every(cell => cell.validated);

            if (allValidated) {
                showWinStatus(true);
                return true;
            }
            
            showWinStatus(false);
            return false;

            /* Ancienne logique (pour r√©f√©rence si besoin de revenir aux lignes/diagonales)
            // Fonction pour v√©rifier si une ligne d'indices est gagnante
            const isWinningLine = (indices) => {
                return indices.every(index => gridState[index].validated);
            };

            // 1. V√©rification des lignes
            for (let i = 0; i < GRID_SIZE; i++) {
                const rowIndices = [];
                for (let j = 0; j < GRID_SIZE; j++) {
                    rowIndices.push(i * GRID_SIZE + j);
                }
                if (isWinningLine(rowIndices)) {
                    showWinStatus(true);
                    return true;
                }
            }

            // 2. V√©rification des colonnes
            for (let j = 0; j < GRID_SIZE; j++) {
                const colIndices = [];
                for (let i = 0; i < GRID_SIZE; i++) {
                    colIndices.push(i * GRID_SIZE + j);
                }
                if (isWinningLine(colIndices)) {
                    showWinStatus(true);
                    return true;
                }
            }

            // 3. V√©rification de la diagonale principale (haut-gauche √† bas-droite)
            const diag1Indices = [];
            for (let i = 0; i < GRID_SIZE; i++) {
                diag1Indices.push(i * GRID_SIZE + i);
            }
            if (isWinningLine(diag1Indices)) {
                showWinStatus(true);
                return true;
            }

            // 4. V√©rification de la deuxi√®me diagonale (haut-droite √† bas-gauche)
            const diag2Indices = [];
            for (let i = 0; i < GRID_SIZE; i++) {
                diag2Indices.push(i * GRID_SIZE + (GRID_SIZE - 1 - i));
            }
            if (isWinningLine(diag2Indices)) {
                showWinStatus(true);
                return true;
            }

            showWinStatus(false);
            return false;
            */
        }

        function showWinStatus(isWon) {
            if (isWon) {
                winStatus.classList.remove('hidden');
                // D√©sactive la grille apr√®s la victoire
                bingoGrid.classList.add('pointer-events-none', 'opacity-50');
            } else {
                winStatus.classList.add('hidden');
                // Assure que la grille est active si on n'a pas gagn√©
                bingoGrid.classList.remove('pointer-events-none', 'opacity-50');
            }
        }


        // --- Rendu et Initialisation ---
        
        // Ceci est la fonction principale de rendu qui utilise l'ajustement dynamique de la police
        function renderGrid(gridState) {
            bingoGrid.innerHTML = '';
            
            // 1. G√©n√©rer et ins√©rer les √©l√©ments (pour que le Grid Layout d√©finisse les hauteurs de ligne)
            gridState.forEach((cell, index) => {
                const cellDiv = document.createElement('div');
                let baseClasses = 'grid-cell font-semibold transition duration-200 shadow-lg border-2 hover:scale-[1.02]';
                
                cellDiv.className = `${baseClasses} ${cell.validated ? 'validated' : 'not-validated'}`;
                cellDiv.textContent = cell.text;
                cellDiv.dataset.index = index;
                bingoGrid.appendChild(cellDiv);
            });

            // 2. Ajuster la taille de la police pour chaque cellule
            // Utiliser requestAnimationFrame pour garantir que le navigateur a termin√© le layout (hauteurs de lignes)
            requestAnimationFrame(() => {
                const cells = bingoGrid.querySelectorAll('.grid-cell');
                
                cells.forEach(cell => {
                    const text = cell.textContent;
                    // Calcule la taille de police pour que le texte tienne dans la hauteur et la largeur de la cellule
                    const bestSize = calculateFontSize(text, cell); 
                    cell.style.fontSize = `${bestSize}px`;
                });
            }); 
            // NOTE: J'ai remplac√© le setTimeout par requestAnimationFrame pour une meilleure performance
            // et une meilleure garantie que le layout est stable avant la mesure.
        }

        function newGame() {
            const shuffledActions = shuffle([...bingoActions]);
            // S'assurer qu'on a assez d'actions
            const selectedActions = shuffledActions.slice(0, TOTAL_SQUARES); 
            if (selectedActions.length < TOTAL_SQUARES) {
                console.error("Pas assez d'actions pour remplir la grille.");
                return;
            }

            const newGridState = selectedActions.map(action => ({
                text: action,
                validated: false
            }));

            renderGrid(newGridState);
            saveGridState(newGridState);
            checkWin(newGridState); 
        }

        function handleGridClick(event) {
            const cellElement = event.target.closest('div');
            // V√©rifie si le clic provient bien d'une cellule de la grille et si la grille n'est pas d√©sactiv√©e
            if (!cellElement || !cellElement.dataset.index || bingoGrid.classList.contains('pointer-events-none')) return;

            const index = parseInt(cellElement.dataset.index, 10);
            let gridState = loadGridState();
            if (!gridState || index >= gridState.length) return;

            gridState[index].validated = !gridState[index].validated;

            // On met √† jour l'√©tat et on re-rend toute la grille, ce qui recalcule les polices au besoin
            renderGrid(gridState);
            saveGridState(gridState);
            checkWin(gridState);
        }

        // --- √âv√©nements ---
        newGridBtn.addEventListener('click', newGame);
        bingoGrid.addEventListener('click', handleGridClick);

        window.onload = function() {
            // Ajout d'un √©couteur d'√©v√©nement pour recalculer les polices lors du redimensionnement
            // Cela g√®re les changements d'orientation mobile ou le redimensionnement du navigateur
            window.addEventListener('resize', () => {
                const storedState = loadGridState();
                if (storedState) {
                    renderGrid(storedState); 
                }
            });

            const storedState = loadGridState();
            if (storedState) {
                // Si un √©tat est stock√©, on le rend et on v√©rifie l'√©tat de la victoire
                renderGrid(storedState);
                checkWin(storedState);
            } else {
                // Sinon, on lance une nouvelle partie
                newGame();
            }
        }
    </script>
</body>
</html>
